% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plmm_prep.R
\name{plmm_prep}
\alias{plmm_prep}
\title{PLMM prep: a function to run checks, SVD, and rotation prior to fitting a PLMM model
This is an internal function for \code{cv.plmm}}
\usage{
plmm_prep(
  X,
  y,
  k = NULL,
  K = NULL,
  diag_K = NULL,
  eta_star = NULL,
  penalty.factor = rep(1, ncol(X)),
  trace = NULL,
  ...
)
}
\arguments{
\item{X}{Design matrix object or a string with the file path to a design matrix. If a string, string will be passed to \code{get_data()}.
Note: X may include clinical covariates and other non-SNP data, but no missing values are allowed.}

\item{y}{Continuous outcome vector. Logistic regression modeling is still in development.}

\item{k}{An integer specifying the number of singular values to be used in
the approximation of the rotated design matrix. This argument is passed to
\code{RSpectra::svds()}. Defaults to full decomposition (i.e., \code{k = min(n, p)}), where n and p are the dimensions
of the \emph{standardized} design matrix.}

\item{K}{Similarity matrix used to rotate the data. This should either be (1) a known matrix that reflects the covariance of y,
(2) an estimate (Default is \(\frac{1}{p}(XX^T)\)), or (3) a list with components 'd' and 'u', as returned by choose_k().}

\item{diag_K}{Logical: should K be a diagonal matrix? This would reflect observations that are unrelated, or that can be treated as unrelated.
Defaults to FALSE. Note: plmm() does not check to see if a matrix is diagonal. If you want to use a diagonal K matrix,
you must set diag_K = TRUE.}

\item{eta_star}{Optional argument to input a specific eta term rather than estimate it from the data. If K is a known covariance matrix
that is full rank, this should be 1.}

\item{penalty.factor}{A multiplicative factor for the penalty applied to each coefficient. If supplied, penalty.factor must be a numeric vector
of length equal to the number of columns of X. The purpose of penalty.factor is to apply differential penalization if some
coefficients are thought to be more likely than others to be in the model. In particular, penalty.factor can be 0, in which
case the coefficient is always in the model without shrinkage.}

\item{trace}{If set to TRUE, inform the user of progress by announcing the beginning of each step of the modeling process. Default is FALSE.}

\item{...}{Not used yet}
}
\value{
List with these components:
\itemize{
\item n: the number of rows in the original design matrix
\item p: the number of columns in the original design matrix
\item y: The vector of outcomes
\item std_X: standardized design matrix
\item std_X_details: a list with 2 vectors:
\itemize{
\item 'center' (values used to center X)
\item 'scale' (values used to scale X)
}
\item s: vector with the eigenvalues of K
\item U: the eigenvectors of K (same as left singular values of X).
\item ns: the indices for the nonsingular values of X
\item penalty.factor: the penalty factors for the penalized non-singular values
\item snp_names: formatted column names of the design matrix
}
}
\description{
PLMM prep: a function to run checks, SVD, and rotation prior to fitting a PLMM model
This is an internal function for \code{cv.plmm}
}
\examples{

\dontrun{
# this is an internal function; to call this, you would need to use the triple 
# colon, e.g., plmmr:::plmm_prep()
prep1 <- plmm_prep(X = admix$X, y = admix$y, trace = TRUE)
prep2 <- plmm_prep(X = admix$X, y = admix$y, diag_K = TRUE, trace = TRUE)
}

}
\keyword{internal}
