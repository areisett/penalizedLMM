% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict-plmm.R
\name{predict.plmm}
\alias{predict.plmm}
\title{Predict method for plmm class}
\usage{
\method{predict}{plmm}(
  object,
  newX,
  type = c("lp", "coefficients", "vars", "nvars", "blup"),
  lambda,
  idx = 1:length(object$lambda),
  X,
  y,
  K = NULL,
  ...
)
}
\arguments{
\item{object}{An object of class \code{plmm}.}

\item{newX}{Design matrix used for computing predicted values if requested. This
can be either a FBM object or a matrix object. \strong{If you supply an FBM object here,
this function assumes that this matrix has been done.} If you need to do standardization,
see \code{big_std()} and \code{process_plink()}.
\strong{Columns must be named!}}

\item{type}{A character argument indicating what type of prediction should be
returned. Options are "lp," "coefficients," "vars," "nvars," and "blup." See details.}

\item{lambda}{A numeric vector of regularization parameter \code{lambda} values
at which predictions are requested.}

\item{idx}{Vector of indices of the penalty parameter \code{lambda} at which
predictions are required. By default, all indices are returned.}

\item{X}{Original design matrix (not including intercept column)
from object. Required if \code{type == 'blup'} and object is too large to be
returned in \code{plmm} object. Again, \strong{columns must be named!}}

\item{y}{Original continuous outcome vector from object.
Required if \code{type == 'blup'}.}

\item{K}{An optional list or matrix as returned by \code{choose_K()}.}

\item{...}{Additional optional arguments}
}
\description{
Predict method for plmm class
}
\details{
Define beta-hat as the coefficients estimated at the value of lambda that minimizes cross-validation error (CVE). Then options for \code{type} are as follows:
\itemize{
\item 'response' (default): uses the product of newX and beta-hat to predict new values of the outcome. This does not incorporate the correlation structure of the data.
For the stats folks out there, this is simply the linear predictor.
\item 'blup' (acronym for Best Linear Unbiased Predictor): adds to the 'response' a value that represents the esetimated random effect. This addition is a way of incorporating
the estimated correlation structure of data into our prediction of the outcome.
\item 'coefficients': returns the estimated beta-hat
\item 'vars': returns the \emph{indicies} of variables (e.g., SNPs) with nonzero coefficients at each value of lambda. EXCLUDES intercept.
\item 'nvars': returns the \emph{number} of variables (e.g., SNPs) with nonzero coefficients at each value of lambda. EXCLUDES intercept.
}
}
\examples{
# fit a model 
fit <- plmm(X = admix$X, y = admix$y)
lp_pred <- predict(fit, newX = admix$X, type = 'lp')
blup_pred <- predict(fit, newX = admix$X, X = admix$X, y = admix$y) # BLUP is default type
lp_mspe <- apply(lp_pred, 2, function(c){crossprod(admix$y - c)})
min(lp_mspe)

blup_mspe <- apply(blup_pred, 2, function(c){crossprod(admix$y - c)})
min(blup_mspe)

cv_fit <- cv.plmm(X = admix$X, y = admix$y)
min(cv_fit$cve)


set.seed(123)
train_idx <- sample(1:nrow(admix$X), 100) # shuffling is important here! Keeps test and train groups comparable.
train <- list(X = admix$X[train_idx,], y = admix$y[train_idx])
test <- list(X = admix$X[-train_idx,], y = admix$y[-train_idx])
fit <- plmm(X = train$X, y = train$y, K = relatedness_mat(train$X))

 # make predictions for all lambda values 
 pred1 <- predict(object = fit, newX = test$X, type = "blup", X = train$X, y = train$y)

 # make predictions for a select number of lambda values
 # use cv to choose a best lambda
 cvfit <- cv.plmm(X = train$X, y = train$y) 
 pred2 <- predict(object = fit, newX = test$X, type = "blup", idx=cvfit$min,
  X = train$X, y = train$y)
 pred3 <- predict(object = fit, newX = test$X, type = "lp", idx=cvfit$min) 
 
  summary(crossprod(y - pred2)) # almost all 0 -- predictions are good! 
  
 \dontrun{
  # file-backed example 
  plmm(X = "~/tmp_files/penncath_lite", penalty = "lasso", trace = T, returnX = FALSE) -> foo
  pen <- bigsnpr::snp_attach("~/tmp_files/penncath_lite.rds")
  y_hat <- predict(foo, newX = pen$genotypes)
  y <- pen$fam$affection
  # notice: many of the rows in pen$genotypes correspond to samples with a missing phenotype
  # to assess the quality of the fit 
  names(y) <- pen$fam$family.ID
  y_idx <- which(as.character(pen$std_X_rownames) \%in\% names(y))
  crossprod(y - y_hat[y_idx,50])/length(y) # estimate of MSPE
 }
 
 
}
